{"/":{"title":"About","data":{"":"Hey, I'm a Senior Software Engineer at Company. I enjoy working with Next.js and crafting beautiful front-end experiences.This portfolio is built with Next.js and a library called Nextra. It allows you to write Markdown and focus on the content of your portfolio.Deploy your own in a few minutes.\nTwitter @yourname\nGitHub @yourname\nInstagram @yourname\nEmail your@name.com"}},"/photos":{"title":"Photos","data":{"":"Here's some of my photography.\nUnsplash ↗ \nUnsplash ↗"}},"/posts":{"title":"Posts","data":{}},"/posts/knowledge-graph-rag":{"title":"Knowledge Graph 통합 RAG 구현","data":{"":"정보 검색과 기계 학습 기반의 자연어 생성 기술의 결합이라 할 수 있는 RAG(Retrieval-Augmented Generation)는 일부 애플리케이션에서 그 효과성이 검증되고 있다. 정보를 처리하는 소프트웨어 애플리케이션에 빠른 속도로 도입 될 것이라는 예측은 이제 어려운 일이 아니다. RAG를 발전시키기 위한 연구와 시도 또한 속도를 내고있다. 지식 그래프 기술을 RAG에 통합하는 접근 방법은 이러한 맥락에서 살펴보아야 한다.전형적인 지식 그래프 기술의 개념과 RAG와 통합 됐을 때 역할에 대해서 알아보고자 한다. 또한 RAG에서 핵심적인 기술 중 하나인 벡터 임베딩 기술과 비교한다. 지식 그래프와 벡터 임베딩을 같을 동일 선상에서 비교하는 것이 아니라 RAG 애플리케이션에서 각자 어떤 역할을 수행하는지 이해를 돕기위한 차원이다. 구체적인 이해를 돕기 위한 지식 그래프를 데이터베이스로 구축하고, 사용자 질의에 대한 정보 탐색을 어떻게 구현할 수 있는지 예제를 통해 살펴본다. 자연어 기반의 정보를 넘어 다양한 유형의 데이터와 형식으로 확장하는 접근 방법에 대한 내용도 포함한다.","지식-그래프c-graph란#지식 그래프(c Graph)란?":"지식 그래프는 정보를 구조화된 상호 연결의 형태로 표현한 것이다. 정보는 사람의 사고 체계에서 사용하는 개념으로 복잡하고 추상적이다. 이를 특정한 구조를 갖는 데이터로 표현하여 소프트웨어 프로그램을 통해서 처리할 수 있도록 하는 것이다. 특징 중 하나는, 프로그래밍 언어와 유사하게, 기계가 처리할 수 있을 뿐 아니라 사람도 여전히 이 표현된 데이터를 이해할 수 있다는 것이다.지식 그래프의 데이터 구조는 엔티티(노드)와 이들 엔티티 간의 관계(엣지)로 구성된다. 엔티티는 현실 세계의 사물, 개념, 아이디어 등에 관한 것이고, 관계는 이러한 엔티티들이 어떤 관계로 연결될 수 있는지를 나타낸다.지식 그래프는 인간이 현실 세계를 이해하고 추론하는 방식에서, 정보를 개별적인 형태로 다루는 것이 아니라, 서로 다른 정보 조각들을 연결해 풍부하게 얽힌 지식 네트워크를 형성한다는 점을 모방한다고 할 수 있다. 엔티티들이 어떠한 관계로 연결 되는지에 대해 일정한 규칙을 기반으로 명확하게 정의하여, 서로 다른 정보 조각들로 부터 얻기 어려운 새로운 정보나 결론을 도출할 수 있도록 한다.[Tripple data structure diagram]","그래프-질의query-및-탐색traversal#그래프 질의(Query) 및 탐색(Traversal)":"지식 그래프의 특징 중 하나는 질의와 탐색을 통해서 관련 정보를 추출하거나 새로운 지식을 유추할 수 있다는 것이다.","rag-애플리케이션-구현에서-지식-그래프의-이점#RAG 애플리케이션 구현에서 지식 그래프의 이점":"RAG는 정보 검색 및 자연어 생성을 통해서 사용자가 입력한 프롬프트에 대해 관련이 높은 응답을 생성할 수 있도록 하는 기술을 말한다. 핵심 컴포넌트는 기계 학습을 통해서 방대한 자연어 데이터를 학습시킨 LLM(Large Language Model)이라 할 수 있으며, 여기에 다양한 데이터 및 정보 처리 기술이 통합될 수 있다. 지식 그래프는 대표적인 사용 사례가 검색 서비스에서 사용자 질의에 따른 결과에 관련성이 높은 구조화 된 지식을 제공하는 것일 만큼, 정보 탐색에서 활용도 높은 기술 중 하나이다. RAG에서 지식 그래프를 통합하여 향상된 결과를 얻을 수 있을 것이라는 기대는 합리적인 것처럼 보인다. 여기서 설명하는 특징들은 이러한 기대를 뒷받침한다.\n구조화된 지식 표현\n지식 그래프는 엔티티와 관계로 구성된 그래프 데이터 구조로 정보를 표현한다. 자연어 기반의 비정형 데이터는 사람이 읽고 이해할 수 있지만, 프로그램이 작업을 수행하기는 어렵다. 또한 프로그램이 연산할 수 있도록 최적화된 데이터 구조는 사람이 직관적으로 이해하기 어려울 수 있다. 지식 그래프의 데이터 구조는 사람이 이해할 수 있으면서도 프로그램이 작업을 수행할 수 있는 형태이다.\n맥락적 이해(Contextual Understanding)\n지식 그래프를 구성하고 있는 관계를 통해서 주어진 상황에서 정보에 대한 맥락을 파악할 수 있다. 문맥에 따라 의미 해석을 달리할 수 있는 자연어의 특성과 이러한 자연어 데이터를 기계 학습을 통해 AI 모델로 생성하고 확률적으로 유추하여 문장을 재생성하는 것이 RAG의 핵심 기술 중 하나라는 점에서 지식 그래프가 맥락을 포함할 수 있다는 것은 의미를 갖는다. 특정 맥락에서 더 일관성 있고 관련성이 높은 결과물을 생성할 수 있는 가능성이 높아지는 것이다.\n추론적 사고(Inferential Reasoning)\n지식 그래프는 그래프 순회 기술을 통해서 질의에 명시적으로 포함되지 않은 새로운 정보를 유추할 수 있다. 이러한 추론 능력은 RAG에서 생성되는 응답의 품질과 완성도 향상에 기여한다.\n지식 통합(Knowledge Integration)\n지식 그래프는 유연한 구조적 특성으로 인해 여러 출처의 정보를 통합할 수 있다. 예를 들어 어떤 용어가 특정 도메인에서 평소와 다른 의미로 사용 된다면, 해당 도메인에 대한 지식 베이스를 지식 그래프로 표현하면 그래프 데이터 구조 내에서 이를 쉽게 통합할 수 있다.\n설명 가능성과 투명성(Explainability and Transparency )\n높은 수준의 복잡도를 갖는 기계 학습 모델에 대한 추론에 있어서 그 과정을 단계별로 모두 이해하고 제어하는 것은 어렵다. 이는 마치 블랙박스와 같아서 애플리케이션이 의도한 결과를 일관성 있게 도출하는 작업에 어려움을 겪게 된다. 지식 그래프는 사람이 직관적으로 이해할 수 있고 그래프 데이터에 대한 쿼리 및 순회 알고리즘을 제어할 수 있다는 점에서 이러한 한계를 보완할 수 있다.\n예를 들어, 애플리케이션에서 필요한 특정 정보가 결과에서 누락됐을 때, 학습 프로세스를 다시 설계하고 수행하거나, 파인튜닝을 위한 작업을 반복하는 것 대신 지식 그래프의 해당 부분에 엔티티와 관계를 추가하고 이를 결과에 포함시키도록 프롬프트나 프로그램 로직을 구현하면 된다.이처럼, 지식 그래프는 RAG의 정확도를 향상시키고 필요에 부합하는 애플리케이션을 구현하는데 도움이 될 수 있다. 특히 자연어 처리 분야에서 다양하게 활용할 수 있는 장점을 가진다.","지식-그래프와-벡터-데이터베이스#지식 그래프와 벡터 데이터베이스":"RAG에 보편적으로 사용되는 기술 중 하나는 벡터 데이터베이스이다. 벡터 데이터베이스는 자연어 기반의 데이터를 벡터 공간의 값으로 표현하여 유사도 등의 연산을 할 수 있다. 두 기술은 정보 탐색에 활용 될수 있다는 것을 제외하면 완전히 다른 기술이지만 각각의 특성을 비교하여 이해하면 보완적으로 사용할 수 있다.\n특징\t지식 그래프\t벡터 데이터베이스\t데이터 구조\t엔티티와 관계를 그래프 데이터 구조로 표현\t고차원 벡터 값으로 문서 혹은 문장을 변환\t검색 메커니즘\t그래프 구조를 탐색하고 정의된 관계를 따라 순회하여 정보 검색 결과를 도출\t벡터 유사도를 연산하여 유사도가 높은 벡터 값과 관련된 정보를 반환\t해석 가능성 (Interpretability)\t사람이 직관적으로 이해할 수 있고 그래프 데이터베이스가 지원하는 라벨, 속성 등을 통해 명확한 표현이 가능\t기본적으로는 벡터 값 자체에 대한 사람의 해석이 어렵고, 유사성 판단에 대한 기준을 파악하기 어려움\t지식 통합\t그래프 데이터 구조 내에서 의도에 따라 편집 가능\t벡터 공간의 정렬이나 앙상블 기법 등 추가적인 처리를 통해서 통합 구현\t추론 능력\t그래프 데이터에 대한 질의 및 순회를 통해 정의된 관계를 연계하여 새로운 통찰 도출\t추론 과정을 파악하고 제어하기 어려움\t\n벡터 데이터베이스는 RAG에서 빼놓을 수 없는 핵심적인 기술이다. 지식 그래프는 벡터 데이터베이스가 가질 수 있는 단점을 보완할 수 있는 가능성이 높은 기술로 평가할 수 있다. 지식 그래프는 구조화된 지식 표현과 일관성 있는 추론에 강점을 갖는 반면에, 벡터 데이터베이스는 비정형 데이터에 대한 의미적 유사성 기반의 정보 탐색에 특화되어 있다.","지식-그래프-구현-방법#지식 그래프 구현 방법":"지식 그래프를 구축하고 RAG에 통합하는 과정에 대한 이해를 돕기 위해 구현 단순화 한 절차에 대해 설명하고 간단한 코드 예제를 살펴본다.\n텍스트 데이터 로딩 및 전처리\n언어 모델 초기화 및 지식 그래프 추출\n지식 그래프 데이터베이스 구축\n지식 그래프를 통한 맥락 인식\n지식 그래프 검색 결과를 언어 모델과 결합하여 최종 응답 생성\n예제는 Python 3.7 이상 버전에서 동작 가능한 코드를 제공한다.\nRAG framework 으로 LangChain 과 LlamIndex 를 사용한다.\n그래프 데이터베이스는 Neo4j를 사용한다.","텍스트-데이터-로딩-및-전처리#텍스트 데이터 로딩 및 전처리":"from langchain.document_loaders import TextLoader\nfrom langchain.text_splitter import CharacterTextSplitter\n# Load text data\ntext = \"\"\"지식 그래프는 정보를 구조화된 상호 연결의 형태로 표현한 것이다. 정보는 사람의 사고 체계에서 사용하는 개념으로 복잡하고 추상적이다. 이를 특정한 구조를 갖는 데이터로 표현하여 소프트웨어 프로그램을 통해서 처리할 수 있도록 하는 것이다. 특징 중 하나는, 프로그래밍 언어와 유사하게, 기계가 처리할 수 있을 뿐 아니라 사람도 여전히 이 표현된 데이터를 이해할 수 있다는 것이다.\n지식 그래프의 데이터 구조는 엔티티(노드)와 이들 엔티티 간의 관계(엣지)로 구성된다. 엔티티는 현실 세계의 사물, 개념, 아이디어 등에 관한 것이고, 관계는 이러한 엔티티들이 어떤 관계로 연결될 수 있는지를 나타낸다.\n지식 그래프는 인간이 현실 세계를 이해하고 추론하는 방식에서, 정보를 개별적인 형태로 다루는 것이 아니라, 서로 다른 정보 조각들을 연결해 풍부하게 얽힌 지식 네트워크를 형성한다는 점을 모방한다고 할 수 있다. 엔티티들이 어떠한 관계로 연결 되는지에 대해 일정한 규칙을 기반으로 명확하게 정의하여, 서로 다른 정보 조각들로 부터 얻기 어려운 새로운 정보나 결론을 도출할 수 있도록 한다.\"\"\"\nloader = TextLoader(text)\ndocuments = loader.load()\ntext_splitter = CharacterTextSplitter(chunk_size=200, chunk_overlap=20)\ntexts = text_splitter.split_documents(documents)\n전체 자연어 데이터를 더 작은 단위로 다루기 위해서 CharacterTextSplitter 인스턴스를 생성한다. chunk_size는 단위 데이터의 크기를 지정하고, chunk_overlap은 인접한 데이터 사이의 중복 영역을 지정하여 각각의 단위 데이터가 문맥을 유지 하도록 한다. 이렇게 지식 베이스의 문서들을 전처리하여 지식 그래프를 자동화된 방식으로 추출할 수 있도록 준비 과정을 수행한다.","언어-모델-초기화-및-지식-그래프-추출#언어 모델 초기화 및 지식 그래프 추출":"예제에서는 OpenAI가 제공하는 API를 활용하여 LLM을 통합한다. RAG 개발 프레임워크 중 하나인 LangChin이 제공하는 라이브러리를 활용하면 보다 쉽게 LLM 모델에 대한 설정과 초기화를 완료할 수 있다. 예제에서는 LLMGraphTransformer > convert_to_graph_documents 를 통해서 자연어 기반의 문서에서 지식 그래프를 추출하고 있다.\nfrom langchain.llms import OpenAI\nfrom langchain.transformers import LLMGraphTransformer\nimport getpass\nimport os\n# OpenAI API 인증 키키\nos.environ[\"OPENAI_API_KEY\"] = getpass.getpass()\n# 초기화\nllm = OpenAI(temperature=0)\n# 지식 그래프 추출출\nllm_transformer = LLMGraphTransformer(llm=llm)\ngraph_documents = llm_transformer.convert_to_graph_documents(texts)","지식-그래프-데이터베이스-구축#지식 그래프 데이터베이스 구축":"Neo4j는 그래프 데이터베이스로 그래프 데이터 관리에 필요한 기능을 제공한다. LangChin에서 제공하는 저장소 라이브러리를 통해서 데이터베이스를 구축한다.\nfrom langchain.graph_stores import Neo4jGraphStore\n# Neo4j 설정\ngraph_store = Neo4jGraphStore(url=\"neo4j://your_neo4j_url\", username=\"your_username\", password=\"your_password\")\ngraph_store.write_graph(graph_documents)","지식-그래프를-통한-맥락-인식#지식 그래프를 통한 맥락 인식":"또 다른, RAG 개발 프레임워크인 LlamaIndex 에서 각각의 라이브러라를 사용한다.\nRetrieverQueryEngine: 지정된 데이터 소스에서 맥락을 로딩하고 이를 활용해 질의에 대한 응답을 생성하는 엔진\nKnowledgeGraphRAGRetriever: 지식 그래프 데이터베이스로부터 필요한 정보를 검색하여 응답을 반환\nResponseSynthesizer: 지식 그래프의 검색 결과를 바탕으로 언어 모델을 이용해서 최종 응답을 생성\nfrom llama_index.core.query_engine import RetrieverQueryEngine\nfrom llama_index.core.retrievers import KnowledgeGraphRAGRetriever\nfrom llama_index.core.response_synthesis import ResponseSynthesizer\n# Retrieve Knowledge for RAG\ngraph_rag_retriever = KnowledgeGraphRAGRetriever(storage_context=graph_store.storage_context, verbose=True)\nquery_engine = RetrieverQueryEngine.from_args(graph_rag_retriever)","지식-그래프-검색-결과를-언어-모델과-결합하여-최종-응답-생성#지식 그래프 검색 결과를 언어 모델과 결합하여 최종 응답 생성":"def query_and_synthesize(query):\n    retrieved_context = query_engine.query(query)\n    response = response_synthesizer.synthesize(query, retrieved_context)\n    print(f\"질문: {query}\")\n    print(f\"답변변: {response}\\n\")\nresponse_synthesizer = ResponseSynthesizer(llm)\n# 1\nquery_and_synthesize(\"지식 그래프를 RAG에 통합하는 방법은?\")\n간단한 예시와 함께 RAG 애플리케이션에서 지식 그래프 데이터베이스를 구축하고 대화형 질의에 대해서 답변을 생성하는 과정을 살펴봤다. 각 과정을 각자의 기술을 적용해서 고도화 할 수 있다.","지식-그래프의-적용#지식 그래프의 적용":"현실 세계에서 정보 탐색에 관한 애플리케이션은 높은 복잡도를 가지며 다양한 형태의 데이터를 다루어야 할 때가 많다. 각 시나리오에 따라 어떻게 RAG 애플리케이션을 확장할 수 있는 접근 방법에 대해서 생각해 보아야 한다.","분산형-지식-그래프-구축#분산형 지식 그래프 구축":"지식 베이스가 방대하거나 대규모의 데이터를 대상으로 지식 그래프를 생성해야 한다면 병렬화, 분산 처리에 대한 고려가 필요하다. 데이터를 여러 파티션으로 나누고, 각 파티션 별로 별도의 지식 그래프를 추출한 후 최종적으로 하나의 지식 그래프로 통합하거나, 지식 그래프에 계층을 나누고 그래프 순회 과정에서 분리된 계층을 통합하여 응답을 생성하는 등의 방식을 고려해야 한다.","증분식-업데이트#증분식 업데이트":"지식 베이스의 내용이 업데이트 될 때, 전체 지식 그래프를 처음부터 새로 구축하는 것이 아니라, 기존 지식 그래프 데이터베이스에 새롭게 업데이트 된 내용을 증분 식으로 반영할 수 있다. 이를 통해서 자원의 효율적인 활용과 애플리케이션의 실시간성을 개선할 수 있을 것이다.","결론#결론":"언어 모델을 활용한 RAG 기술은 지속적인 발전을 통해서 여러 분야의 문제 해결에 활용될 것으로 예상된다. RAG의 발전을 보완할 수 있는 지식 그래프 기술 또한 이에 맞추어 방향성 일치 시키고 발전을 거듭할 것이다.","지식-그래프-구축에서-과제#지식 그래프 구축에서 과제":"이해를 돕기 위해 간략히 작성된 예제와는 달리 실제 비즈니스 환경의 문제를 해결하기 위한 애플리케이션의 요구사항은 훨씬 더 복잡하고 도전적이다. 특히 지식 그래프의 품질이 전반적인 애플리케이션의 품질과 연결된다. 특정 언어 모델과 RAG 개발 프레임워크에 의존하여 생성된 지식 그래프는 그 한계가 뚜렷하다. 일부 지식 그래프의 사례에서 처럼 해당 분야의 전문가가 직접 데이터베이스를 구축하는 일은 현실적인 생산성 문제에 직면할 것이다. 언어 모델을 활용하여 자동화하고 이를 평가할 수 있는 모델을 도입하여 지속적으로 지식 그래프의 품질을 향상시키고, 전문가가 직접 지식 그래프를 이해하고 수정할 수 있도록 풍부한 인터페이스 제공을 통한 작업 프로세스를 정립하는 것 등이 계속되는 도전 과제라고 할 수 있다.\n참고. https://www.datacamp.com/blog/what-is-retrieval-augmented-generation-rag"}},"/posts/markdown":{"title":"Markdown Examples","data":{"h2-heading#h2 Heading":"","h3-heading#h3 Heading":"","h4-heading#h4 Heading":"","h5-heading#h5 Heading":"","h6-heading#h6 Heading":"","emphasis#Emphasis":"This is bold textThis is italic textStrikethrough","blockquotes#Blockquotes":"Develop. Preview. Ship. – Vercel","lists#Lists":"Unordered\nLorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa\nOrdered\nLorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa","code#Code":"Inline code\nexport default function Nextra({ Component, pageProps }) {\n  return (\n    <>\n      <Head>\n        <link\n          rel=\"alternate\"\n          type=\"application/rss+xml\"\n          title=\"RSS\"\n          href=\"/feed.xml\"\n        />\n        <link\n          rel=\"preload\"\n          href=\"/fonts/Inter-roman.latin.var.woff2\"\n          as=\"font\"\n          type=\"font/woff2\"\n          crossOrigin=\"anonymous\"\n        />\n      </Head>\n      <Component {...pageProps} />\n    </>\n  )\n}","tables#Tables":"Option\tDescription\tFirst\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\tSecond\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\tThird\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.","links#Links":"Next.js\nNextra\nVercel","footnotes#Footnotes":"Footnote .\nFootnote .\nFootnote can have markupand multiple paragraphs.Footnote text."}},"/tags/[tag]":{"title":"Tagged Posts","data":{}},"/posts/pages":{"title":"Next.js Pages","data":{"":"In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name.Example: If you create pages/about.js that exports a React component like below, it will be accessible at /about.\nfunction About() {\n  return <div>About</div>\n}\nexport default About","pages-with-dynamic-routes#Pages with Dynamic Routes":"Next.js supports pages with dynamic routes. For example, if you create a file called pages/posts/[id].js, then it will be accessible at posts/1, posts/2, etc.\nTo learn more about dynamic routing, check the Dynamic Routing documentation.","pre-rendering#Pre-rendering":"By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO.Each generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive. (This process is called hydration.)","two-forms-of-pre-rendering#Two forms of Pre-rendering":"Next.js has two forms of pre-rendering: Static Generation and Server-side Rendering. The difference is in when it generates the HTML for a page.\nStatic Generation (Recommended): The HTML is generated at build time and will be reused on each request.\nServer-side Rendering: The HTML is generated on each request.\nImportantly, Next.js lets you choose which pre-rendering form you'd like to use for each page. You can create a \"hybrid\" Next.js app by using Static Generation for most pages and using Server-side Rendering for others.We recommend using Static Generation over Server-side Rendering for performance reasons. Statically generated pages can be cached by CDN with no extra configuration to boost performance. However, in some cases, Server-side Rendering might be the only option.You can also use Client-side Rendering along with Static Generation or Server-side Rendering. That means some parts of a page can be rendered entirely by client side JavaScript. To learn more, take a look at the Data Fetching documentation.","static-generation-recommended#Static Generation (Recommended)":"If a page uses Static Generation, the page HTML is generated at build time. That means in production, the page HTML is generated when you run next build . This HTML will then be reused on each request. It can be cached by a CDN.In Next.js, you can statically generate pages with or without data. Let's take a look at each case.","static-generation-without-data#Static Generation without data":"By default, Next.js pre-renders pages using Static Generation without fetching data. Here's an example:\nfunction About() {\n  return <div>About</div>\n}\nexport default About\nNote that this page does not need to fetch any external data to be pre-rendered. In cases like this, Next.js generates a single HTML file per page during build time.","static-generation-with-data#Static Generation with data":"Some pages require fetching external data for pre-rendering. There are two scenarios, and one or both might apply. In each case, you can use a special function Next.js provides:\nYour page content depends on external data: Use getStaticProps.\nYour page paths depend on external data: Use getStaticPaths (usually in addition to getStaticProps).","scenario-1-your-page-content-depends-on-external-data#Scenario 1: Your page content depends on external data":"Example: Your blog page might need to fetch the list of blog posts from a CMS (content management system).\n// TODO: Need to fetch `posts` (by calling some API endpoint)\n//       before this page can be pre-rendered.\nfunction Blog({ posts }) {\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\nexport default Blog\nTo fetch this data on pre-render, Next.js allows you to export an async function called getStaticProps from the same file. This function gets called at build time and lets you pass fetched data to the page's props on pre-render.\nfunction Blog({ posts }) {\n  // Render posts...\n}\n// This function gets called at build time\nexport async function getStaticProps() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n  // By returning { props: { posts } }, the Blog component\n  // will receive `posts` as a prop at build time\n  return {\n    props: {\n      posts\n    }\n  }\n}\nexport default Blog\nTo learn more about how getStaticProps works, check out the Data Fetching documentation.","scenario-2-your-page-paths-depend-on-external-data#Scenario 2: Your page paths depend on external data":"Next.js allows you to create pages with dynamic routes. For example, you can create a file called pages/posts/[id].js to show a single blog post based on id. This will allow you to show a blog post with id: 1 when you access posts/1.\nTo learn more about dynamic routing, check the Dynamic Routing documentation.\nHowever, which id you want to pre-render at build time might depend on external data.Example: suppose that you've only added one blog post (with id: 1) to the database. In this case, you'd only want to pre-render posts/1 at build time.Later, you might add the second post with id: 2. Then you'd want to pre-render posts/2 as well.So your page paths that are pre-rendered depend on external data**.** To handle this, Next.js lets you export an async function called getStaticPaths from a dynamic page (pages/posts/[id].js in this case). This function gets called at build time and lets you specify which paths you want to pre-render.\n// This function gets called at build time\nexport async function getStaticPaths() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n  // Get the paths we want to pre-render based on posts\n  const paths = posts.map((post) => ({\n    params: { id: post.id }\n  }))\n  // We'll pre-render only these paths at build time.\n  // { fallback: false } means other routes should 404.\n  return { paths, fallback: false }\n}\nAlso in pages/posts/[id].js, you need to export getStaticProps so that you can fetch the data about the post with this id and use it to pre-render the page:\nfunction Post({ post }) {\n  // Render post...\n}\nexport async function getStaticPaths() {\n  // ...\n}\n// This also gets called at build time\nexport async function getStaticProps({ params }) {\n  // params contains the post `id`.\n  // If the route is like /posts/1, then params.id is 1\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n  // Pass post data to the page via props\n  return { props: { post } }\n}\nexport default Post\nTo learn more about how getStaticPaths works, check out the Data Fetching documentation.","when-should-i-use-static-generation#When should I use Static Generation?":"We recommend using Static Generation (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.You can use Static Generation for many types of pages, including:\nMarketing pages\nBlog posts\nE-commerce product listings\nHelp and documentation\nYou should ask yourself: \"Can I pre-render this page ahead of a user's request?\" If the answer is yes, then you should choose Static Generation.On the other hand, Static Generation is not a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.In cases like this, you can do one of the following:\nUse Static Generation with Client-side Rendering: You can skip pre-rendering some parts of a page and then use client-side JavaScript to populate them. To learn more about this approach, check out the Data Fetching documentation.\nUse Server-Side Rendering: Next.js pre-renders a page on each request. It will be slower because the page cannot be cached by a CDN, but the pre-rendered page will always be up-to-date. We'll talk about this approach below.","server-side-rendering#Server-side Rendering":"Also referred to as \"SSR\" or \"Dynamic Rendering\".\nIf a page uses Server-side Rendering, the page HTML is generated on each request.To use Server-side Rendering for a page, you need to export an async function called getServerSideProps. This function will be called by the server on every request.For example, suppose that your page needs to pre-render frequently updated data (fetched from an external API). You can write getServerSideProps which fetches this data and passes it to Page like below:\nfunction Page({ data }) {\n  // Render data...\n}\n// This gets called on every request\nexport async function getServerSideProps() {\n  // Fetch data from external API\n  const res = await fetch(`https://.../data`)\n  const data = await res.json()\n  // Pass data to the page via props\n  return { props: { data } }\n}\nexport default Page\nAs you can see, getServerSideProps is similar to getStaticProps, but the difference is that getServerSideProps is run on every request instead of on build time.To learn more about how getServerSideProps works, check out our Data Fetching documentation","summary#Summary":"We've discussed two forms of pre-rendering for Next.js.\nStatic Generation (Recommended): The HTML is generated at build time and will be reused on each request. To make a page use Static Generation, either export the page component, or export getStaticProps (and getStaticPaths if necessary). It's great for pages that can be pre-rendered ahead of a user's request. You can also use it with Client-side Rendering to bring in additional data.\nServer-side Rendering: The HTML is generated on each request. To make a page use Server-side Rendering, export getServerSideProps. Because Server-side Rendering results in slower performance than Static Generation, use this only if absolutely necessary."}}}